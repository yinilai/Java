import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.math.RoundingMode;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import ethicalengine.*;
import ethicalengine.Character;

/**
 * The audit class is used for audit the given scenarios based on their characteristics 
 * and corresponding decision made either by the user or the built-in algorithm in
 * this program. It contains two kinds of constructors, AuditScenario method, 
 * getter and setter methods, toString method, printStatistic method, 
 * and printToFile methods.
 * 
 * Final_Project: Moral Machine
 * @author Yini Lai
 * username yinlai
 * student_ID 1127650
 */
public class Audit
{
	private String auditType;
	private String DEFAULT_AUDITTYPE = "Unspecified";
	private int runs, totalSurvivorAge, NumOfSurvivorPerson;
	private double averageSurvivorAge;
	private Scenario[] scenarios;
	private HashMap<String, Integer> AllCharacterMap = new HashMap<String, Integer>(); 
	private HashMap<String, Integer> SaveCharacterMap = new HashMap<String, Integer>();
	private HashMap<String, Double> SaveRatioMap = new HashMap<String, Double>();

	/**
	 * Empty constructor of Audit class
	 */
	public Audit()
	{
		this.auditType = DEFAULT_AUDITTYPE;
	}
	
	/**
	 * Constructor with parameter scenarios
	 * @param scenarios A list of scenarios
	 */
	public Audit(Scenario[] scenarios) 
	{
		this.scenarios = scenarios;
		this.auditType = DEFAULT_AUDITTYPE;
	}
	
	/**
	 * Run function without any paramter will run the scenarios given by 
	 * the Audit instance when it was created. It will run all the scenarios 
	 * in the scenarios list one by one and let the Decision Algorithm in EthicalEngine class
	 * make decision for each of them. In addition, it will invoke the auditScenario function
	 * to audit the decision made by the algorithm and save them to this audit class.
	 */
	public void run() 
	{
		for(Scenario scenario: this.scenarios)
		{
			this.runs++;
			EthicalEngine.Decision decision = EthicalEngine.decide(scenario);
			AuditScenario(scenario, decision);
		}
	}

	/**
	 * Run function with parameter runs will run specific number of scenarios given by this 
	 * parameter funs. These scenarios will be randomly generated by the ScenarioGenerator 
	 * class. After each scenario was generated, it will call the algorithm decision method
	 * in EthicalEngine class to made decision on it. Finally, it will audit the deicision
	 * and save the result to the constructed audit class.
	 * @param runs the number of runs
	 */
	public void run(int runs)
	{	
		this.runs = this.runs + runs;
		while (runs >0)
		{
			EthicalEngine.Decision decision = null;
			Scenario scenario = new ScenarioGenerator().generate(); 
			decision = EthicalEngine.decide(scenario);
			AuditScenario(scenario, decision);
			runs--;
		}
	}
	
	/**
	 * setter method: set the number of scenarios to be audit in this round
	 * @param run the number of scenarios to be run
	 */
	public void setRun(int run)
	{
		this.runs = this.runs + run;
	}
	
	/**
	 * setter method: set the name of this audit class. \n
	 * For example: when auditing the decision algorithm given by this program,
	 * can setAuditType("Algorithm").
	 * @param name The name of the audit instance
	 */
	public void setAuditType(String name)
	{
		if(name != null)
			this.auditType = name;
		else
			this.auditType = DEFAULT_AUDITTYPE;
	}
	
	/**
	 * getter method: get the name of this audit instance
	 * @return a string which is the type/name of the audit instance
	 */
	public String getAuditType()
	{
		return auditType; 
	}

	/**
	 * This audit scenario function will audit the given scenario based on its characteristics 
	 * and the decision made and these statistics will be incrementally update when new 
	 * scenario is audited. The statistics contains in the audit includes
	 * age categary, gender, body type, profession, pregnant, class type(person or animal),
	 * species, legality(red or green light), you.
	 * This function will invoke a couples of help function including:
	 * addAllCharacter(Set<Map.Entry<String, Integer>> set),
	 * addAllCharacter(String character, int countpa, int countpe),
	 * addSaveCharacter(Set<Map.Entry<String, Integer>> set),
	 * addSaveCharacter(String character, int count),
	 * PersonLst(Character[] characters),
	 * AnimalLst(Character[] characters),
	 * PetCount(Animal[] animalLst),
	 * PregnantCount(Person[] personLst),
	 * CharacteristicsStatistic(Person[] personLst),
	 * SpeciesStatistic(Animal[] animalLst).
	 * 
	 * @param scenario given scenario to be audited
	 * @param decision given decision made either by the user or the built-in algorithm. 
	 */
	public void AuditScenario(Scenario scenario, EthicalEngine.Decision decision)
	{
		Integer allValue, saveValue, HAVEYOU = 1, NOAEGUMENT = 0;
		String character;
		Character[] passengers, pedestrians;
		Animal[] peAnimal, paAnimal;
		Person[] pePerson, paPerson;
		
		//This part will get all the basic information which may help to audit the scenario
		passengers = scenario.getPassengers();
		pedestrians = scenario.getPedestrians();
		paPerson = PersonLst(passengers);
		pePerson = PersonLst(pedestrians);
		paAnimal = AnimalLst(passengers);
		peAnimal = AnimalLst(pedestrians);
		
		if(scenario.hasYouInCar() || scenario.hasYouInLane())
			addAllCharacter("you", HAVEYOU, NOAEGUMENT);
		
		if(scenario.isLegalCrossing())
			addAllCharacter("green", passengers.length, pedestrians.length);
		else
			addAllCharacter("red", passengers.length, pedestrians.length);

		//Add all the information about all the aduit factors
		addAllCharacter("person", paPerson.length, pePerson.length); //type
		addAllCharacter("animal", paAnimal.length, peAnimal.length);
		addAllCharacter("pet", PetCount(paAnimal), PetCount(peAnimal)); //pet
		addAllCharacter("pregnant", PregnantCount(paPerson), PregnantCount(pePerson)); //pregnant		
		addAllCharacter(CharacteristicsStatistic(paPerson)); //age
		addAllCharacter(CharacteristicsStatistic(pePerson));
		addAllCharacter(SpeciesStatistic(paAnimal));  //species
		addAllCharacter(SpeciesStatistic(peAnimal));
		
		//This part will record information about those factors of saved characters
		if(decision == EthicalEngine.Decision.PASSENGERS)
		{
			addSaveCharacter("person", paPerson.length);
			addSaveCharacter("animal", paAnimal.length);
			addSaveCharacter("pet", PetCount(paAnimal));
			addSaveCharacter("pregnant", PregnantCount(paPerson));
			addSaveCharacter(CharacteristicsStatistic(paPerson));
			addSaveCharacter(SpeciesStatistic(paAnimal));
			if(scenario.isLegalCrossing())
				addSaveCharacter("green", passengers.length);
			else
				addSaveCharacter("red", passengers.length);
			if(scenario.hasYouInCar())
				addSaveCharacter("you", HAVEYOU);
			calAverageSurvivorAge(paPerson);
		}
		else if (decision == EthicalEngine.Decision.PEDESTRIANS)
		{
			addSaveCharacter("person", pePerson.length);
			addSaveCharacter("animal", peAnimal.length);
			addSaveCharacter("pet", PetCount(peAnimal));
			addSaveCharacter("pregnant", PregnantCount(pePerson));
			addSaveCharacter(CharacteristicsStatistic(pePerson));
			addSaveCharacter(SpeciesStatistic(peAnimal));	
			if(scenario.isLegalCrossing())
				addSaveCharacter("green", pedestrians.length);
			else
				addSaveCharacter("red", pedestrians.length);
			if(scenario.hasYouInLane())
				addSaveCharacter("you", HAVEYOU);
			calAverageSurvivorAge(pePerson);
		}
		
		//This part will calculate the survival ratios which will be update once new
		//scenario be audited. 
		Set<Map.Entry<String, Integer>> AllCharacterSet = AllCharacterMap.entrySet();
		for(Map.Entry<String, Integer> node: AllCharacterSet)
		{
			Double ratio;
			
			character = node.getKey();
			allValue = node.getValue();
			if(SaveCharacterMap.containsKey(character))
			{
				saveValue = SaveCharacterMap.get(character);
				ratio = (double) saveValue / (double) allValue;
			}
			else 
				ratio = (double) 0;
			SaveRatioMap.put(character, ratio);
		}
	}
	
	
	private void addAllCharacter(Set<Map.Entry<String, Integer>> set)
	{
		Integer value;
		for(Map.Entry<String, Integer> node : set)
		{
			if(AllCharacterMap.containsKey(node.getKey()))
			{
				value = AllCharacterMap.get(node.getKey());
				AllCharacterMap.put(node.getKey(), value + node.getValue());
			}
			else
				AllCharacterMap.put(node.getKey(), node.getValue());
		}
	}
	
	private void addAllCharacter(String character, int countpa, int countpe)
	{
		Integer value;
		if(countpa != 0 || countpe != 0)
		{
			if(AllCharacterMap.containsKey(character))
			{
				value = AllCharacterMap.get(character);
				AllCharacterMap.put(character, value + countpa + countpe);
			}
			else
				AllCharacterMap.put(character, countpa + countpe);
		}
	}
	
	private void addSaveCharacter(Set<Map.Entry<String, Integer>> set)
	{
		Integer value;
		for(Map.Entry<String, Integer> node : set)
		{
			if(SaveCharacterMap.containsKey(node.getKey()))
			{
				value = SaveCharacterMap.get(node.getKey());
				SaveCharacterMap.put(node.getKey(), value + node.getValue());
			}
			else
				SaveCharacterMap.put(node.getKey(), node.getValue());
		}
	}
	
	private void addSaveCharacter(String character, int count)
	{
		Integer value;
		if(count != 0)
		{
			if(SaveCharacterMap.containsKey(character))
			{
				value = SaveCharacterMap.get(character);
				SaveCharacterMap.put(character, value + count);
			}
			else
				SaveCharacterMap.put(character, count);
		}
	}
	
	private Person[] PersonLst(Character[] characters)
	{
		ArrayList<Person> personLst = new ArrayList<Person>();
		for(int i = 0; i < characters.length; i++)
		{
			if(characters[i] instanceof Person)
			{
				personLst.add((Person)characters[i]);
			}
		}
		Person[] PersonLst = new Person[personLst.size()]; 
		PersonLst = personLst.toArray(PersonLst); 
		return PersonLst;
	}
	
	private Animal[] AnimalLst(Character[] characters)
	{
		ArrayList<Animal> animalLst = new ArrayList<Animal>();
		for(int i = 0; i < characters.length; i++)
		{
			if(characters[i] instanceof Animal)
			{
				animalLst.add((Animal)characters[i]);
			}
		}
		
		Animal[] AnimalLst = new Animal[animalLst.size()]; 
		AnimalLst = animalLst.toArray(AnimalLst); 
		return AnimalLst;
	}
	
	private int PetCount(Animal[] animalLst)
	{
		int count = 0;
		if(animalLst.length != 0)
		{
			for (Animal animal: animalLst)
			{
				if(animal != null)
					if(animal.isPet())
						count++;
			}
		}
		return count;
	}
	
	private int PregnantCount(Person[] personLst)
	{
		int count = 0;
		if(personLst.length != 0)
		{
			for (Person person: personLst)
			{
				if(person != null)
					if(person.isPregnant())
						count++;
			}
		}
		return count;
	}
	
	private Set<Map.Entry<String, Integer>> CharacteristicsStatistic(Person[] personLst)
	{
		int count = 1;
		String agecategory, gender, bodytype, profession;
		HashMap<String, Integer> CharacteristicsMap = new HashMap<String, Integer>();
		for (Person person: personLst)
		{ 
			if(person != null) 
			{
				agecategory = person.getAgeCategory().toString().toLowerCase();
				if(CharacteristicsMap.containsKey(agecategory))
					CharacteristicsMap.put(agecategory, CharacteristicsMap.get(agecategory) + 1);
				else
					CharacteristicsMap.put(agecategory, count);
				
				gender = person.getGender().toString().toLowerCase(); //gender
				if(!gender.equals("unknown"))
				{
					if(CharacteristicsMap.containsKey(gender))
						CharacteristicsMap.put(gender, CharacteristicsMap.get(gender) + 1);
					else
						CharacteristicsMap.put(gender, count);
				}
				
				bodytype = person.getBodyType().toString().toLowerCase(); //bodytype
				if(!bodytype.equals("unspecified"))
				{
					if(CharacteristicsMap.containsKey(bodytype))
						CharacteristicsMap.put(bodytype, CharacteristicsMap.get(bodytype) + 1);
					else
						CharacteristicsMap.put(bodytype, count);
				}
				
				profession = person.getProfession().toString().toLowerCase(); //profession
				if(!profession.equals("none"))
				{
					if(CharacteristicsMap.containsKey(profession))
						CharacteristicsMap.put(profession, CharacteristicsMap.get(profession) + 1);
					else
						CharacteristicsMap.put(profession, count);
				}
				
				if(person.isYou())
				{
					if(CharacteristicsMap.containsKey("you"))
						CharacteristicsMap.put("you", CharacteristicsMap.get("you") + 1);
					else
						CharacteristicsMap.put("you", count);
				}
			}
		}
		
		Set<Map.Entry<String, Integer>> set = CharacteristicsMap.entrySet();
		return set;
	}
	
	/**
	 * This private calAvergaeSurvivorAge method will update the averge age for the survivors.
	 * It is a help function of toString method
	 * @param personLst list of Person instance
	 */
	private void calAverageSurvivorAge(Person[] personLst)
	{
		if(personLst.length != 0)
		{
			for (Person person: personLst)
			{
				if(person != null)
				{
					totalSurvivorAge = totalSurvivorAge + person.getAge();
					NumOfSurvivorPerson++;
				}				
			}
		}
		averageSurvivorAge = (double)totalSurvivorAge/(double)NumOfSurvivorPerson;
	}
	
	private Set<Map.Entry<String, Integer>> SpeciesStatistic(Animal[] animalLst)
	{
		HashMap<String, Integer> SpeciesMap = new HashMap<String, Integer>();
		int count = 1;
		for(Animal animal: animalLst)
		{
			if(animal != null)
			{
				String species = (animal.getSpecies().toLowerCase());
				if(SpeciesMap.containsKey(species))
					SpeciesMap.put(species, SpeciesMap.get(species) + 1);
				else
					SpeciesMap.put(species,count);
			}
		}
		Set<Map.Entry<String, Integer>> set = SpeciesMap.entrySet();
		return set;
	}
	
	private Set<Map.Entry<String, Double>> sortByComparator(Set<Map.Entry<String, Double>> map) 
    {
        List<Entry<String, Double>> list = new LinkedList<Entry<String, Double>>(map);

        // Sorting the list based on values and if there is a tie sort by the key
        Collections.sort(list, new Comparator<Entry<String, Double>>()
        {
            public int compare(Entry<String, Double> o1,
                    Entry<String, Double> o2)
            {
            	DecimalFormat df = new DecimalFormat("##.#");
        		df.setRoundingMode(RoundingMode.DOWN);
        		Double value1 = Double.parseDouble(df.format(o1.getValue()));
        		Double value2 = Double.parseDouble(df.format(o2.getValue()));
                int comparevalue =  value2.compareTo(value1);
                if(comparevalue != 0)
                    return comparevalue;
                else
                    return o1.getKey().compareTo(o2.getKey());
            }
        });

        Map<String, Double> sortedMap = new LinkedHashMap<String, Double>();
        for (Entry<String, Double> entry : list)
        {
            sortedMap.put(entry.getKey(), entry.getValue());
        }

        return sortedMap.entrySet();
    } 
	
	/**
	 * This is the rewrite toString method for audit class. It will return the audit results.
	 * If there is no scenario audit, it will show "no audit available" information.
	 */
	public String toString()
	{
		DecimalFormat df = new DecimalFormat("##.#");
		df.setRoundingMode(RoundingMode.DOWN);
		if(!SaveRatioMap.isEmpty())
		{
			Set<Map.Entry<String, Double>> SaveRatioSet 
			= sortByComparator(SaveRatioMap.entrySet());
			StringBuilder ScenarioString = new StringBuilder();
			ScenarioString.append("======================================\n");
			ScenarioString.append("# " + this.auditType + " Audit\n");
			ScenarioString.append("======================================\n");
			ScenarioString.append("- % SAVED AFTER " + this.runs + " RUNS\n");
			for(Map.Entry<String, Double> node: SaveRatioSet)
			{
				ScenarioString.append(node.getKey() + ": " + String.format("%.1f", 
						Double.parseDouble(df.format(node.getValue()))) + "\n");
			}
			ScenarioString.append("--\n");
			ScenarioString.append("average age: " + String.format("%.1f", 
					Double.parseDouble(df.format(this.averageSurvivorAge))) + "\n");
			return ScenarioString.toString();
		}
		else
			return "no audit available"; 
	}
	
	/**
	 * This is the print statistic method. When it is invoked, the audit statistics
	 * will be printed to the console.
	 */
	public void printStatistic()
	{
		System.out.print(toString());
	}
	
	/**
	 * This method is for print the statistics to the given file. if the directory of 
	 * given file path does not exist, it will print the error message and exit the 
	 * program
	 * @param filepath given file/file path that the audit statistics will be saved
	 * @throws IOException if there are failed or interrupted I/O operations.
	 */
	public void printToFile(String filepath) throws IOException
	{
		BufferedWriter outputFile = null;		
		File fileObject = new File(filepath);
		if(fileObject.exists())
		{
			outputFile = new BufferedWriter(new FileWriter(filepath, true));
		}
		else if(fileObject.getParent() == null)
		{
			outputFile = new BufferedWriter(new FileWriter(filepath));
		}
		else if(new File(fileObject.getParent()).isDirectory())
			outputFile = new BufferedWriter(new FileWriter(filepath));
		else
		{
			System.out.println("ERROR: could not print results. "
					+ "Target directory does not exist.");
			System.exit(0);
		}			
		outputFile.write(toString());
		outputFile.close();
	}
}

